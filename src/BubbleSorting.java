import java.util.Arrays;

public class BubbleSorting {

    public static void main(String[] args) {
        int[] mas = {11, 3, 14, 16, 7};

        boolean isSorted = false;
        int buf;
        while (!isSorted) {
            isSorted = true;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    isSorted = false;

                    buf = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = buf;
                }
            }
        }
        System.out.println(Arrays.toString(mas));
    }
}
//1. Сначала мы создали массив mas, который хотим отсортировать.
//
//2. Далее создали переменную isSorted, которая будет таким себе флажком того, отсортирован ли уже массив или нет.
//
//3. На следующей строчке мы создали переменную buf, которая нам пригодится при обмене.
//
//4. Собственно, далее создали цикл, который будет делать проход за проходом. Так, как мы не знаем, сколько циклов нужно сделать, то использовали цикл while. Если призабыли, какие есть циклы в Java, почитайте нашу статью о циклах в Java. В худшем случае (элемент с самым маленьким значением находится в конце) нам придется сделать столько проходов, сколько элементов в массиве. В лучшем случае, то есть если массив изначально уже отсортирован, мы сделаем один единственный проход для того, чтобы убедиться, что ни одного обмена не было.
//
//Первым действием в цикле будет установка значения в true, то есть изначально мы предполагаем, что массив отсортирован. А дальше нам нужно попарно сравнить все элементы массива. Соответственно, нам нужно использовать еще один цикл внутри внешнего. В этом случае мы точно знаем, сколько итераций будет, поэтому используем цикл for. Обратите внимание, что правая граница не на mas.length, а mas.length – 1, поскольку мы сравниваем i-й и i+1-й элементы, и чтобы мы не вышли за пределы массива, делаем на 1 цикл меньше.
//
//В цикле for проверяем, больши да, то устанавливаем флажек отсортированости в false (есть обмен, поэтому массив все еще не отсортирован). Далее делаем обмен через созданную ранее переменную buf. Собственно, все. Таким образом, цикл while будет работать, пока переменная isSorted будет в положении false на момент окончания попарной проверки. А это возможно только при отсутствии ситуаций, когда mas[i] > mas[i + 1], то есть при отсутствии обменов. Вот так вот.е ли i-й элемент, чем элемент i+1. Есл